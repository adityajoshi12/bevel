apiVersion: batch/v1
kind: Job
metadata:
  name: approvechaincode-peer0-supplychain-1-1
  namespace: carrier-net
  labels:
    app: approvechaincode-peer0-supplychain-1-1
    app.kubernetes.io/instance: approve-carrier-allchannel-peer0supplychain1-1
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: approvechaincode-supplychain-1-1
    helm.sh/chart: approve_chaincode-0.2.0
  annotations:
    helm.fluxcd.io/antecedent: carrier-net:helmrelease/approve-carrier-allchannel-peer0supplychain1-1
    meta.helm.sh/release-name: approve-carrier-allchannel-peer0supplychain1-1
    meta.helm.sh/release-namespace: carrier-net
spec:
  parallelism: 1
  completions: 1
  backoffLimit: 10
  selector:
    matchLabels:
      controller-uid: 900bef2e-edd1-41a7-b68b-6930d1ec6153
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: approvechaincode-peer0-supplychain-1-1
        app.kubernetes.io/instance: approve-carrier-allchannel-peer0supplychain1-1
        app.kubernetes.io/name: approvechaincode-supplychain1-1
        controller-uid: 900bef2e-edd1-41a7-b68b-6930d1ec6153
        helm.sh/chart: approve_chaincode-0.2.0
        job-name: approvechaincode-peer0-supplychain-1-1
    spec:
      volumes:
        - name: certificates
          emptyDir:
            medium: Memory
      initContainers:
        - name: certificates-init
          image: index.docker.io/hyperledgerlabs/alpine-utils:1.0
          command:
            - sh
            - '-c'
          args:
            - >-
              #!/usr/bin/env sh

              validateVaultResponse () {
                if echo ${2} | grep "errors"; then
                  echo "ERROR: unable to retrieve ${1}: ${2}"
                  exit 1
                fi
                if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
                then
                  http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
                  --header "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" \
                  ${VAULT_ADDR}/v1/${vault_secret_key})
                  curl_response=$?
                  if test "$http_code" != "200" ; then
                      echo "Http response code from Vault - $http_code"
                      if test "$curl_response" != "0"; then
                         echo "Error: curl command failed with error code - $curl_response"
                         exit 1
                      fi
                  fi
                fi
              }


              KUBE_SA_TOKEN=$(cat
              /var/run/secrets/kubernetes.io/serviceaccount/token)

              echo "Getting secrets from Vault Server: ${VAULT_ADDR}"

              # Login to Vault and so I can get an approle token

              VAULT_CLIENT_TOKEN=$(curl -sS  --request POST
              ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login \
                -H "Content-Type: application/json" \
                -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | \
                jq -r 'if .errors then . else .auth.client_token end')
              validateVaultResponse 'vault login token' "${VAULT_CLIENT_TOKEN}"


              vault_secret_key="${VAULT_ORDERER_SECRET_PREFIX}/tls"

              echo "Getting Orderer TLS certificates from Vault using key
              $vault_secret_key"


              OUTPUT_PATH="${MOUNT_PATH}/orderer/tls"

              LOOKUP_SECRET_RESPONSE=$(curl -sS  \
                --header "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" \
                ${VAULT_ADDR}/v1/${vault_secret_key} | jq -r 'if .errors then . else . end')

              validateVaultResponse "secret (${vault_secret_key})"
              "${LOOKUP_SECRET_RESPONSE}" "LOOKUPSECRETRESPONSE"


              TLS_CA_CERT=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r
              '.data.data["ca.crt"]')


              mkdir -p ${OUTPUT_PATH}

              echo "${TLS_CA_CERT}" >> ${OUTPUT_PATH}/ca.crt


              vault_secret_key="${VAULT_PEER_SECRET_PREFIX}/msp"

              echo "Getting MSP certificates from Vault using key
              $vault_secret_key"


              OUTPUT_PATH="${MOUNT_PATH}/admin/msp"

              LOOKUP_SECRET_RESPONSE=$(curl -sS  \
                --header "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" \
                ${VAULT_ADDR}/v1/${vault_secret_key} | jq -r 'if .errors then . else . end')
              validateVaultResponse "secret (${vault_secret_key})"
              "${LOOKUP_SECRET_RESPONSE}" "LOOKUPSECRETRESPONSE"


              ADMINCERT=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r
              '.data.data["admincerts"]')

              CACERTS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r
              '.data.data["cacerts"]')

              KEYSTORE=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r
              '.data.data["keystore"]')

              SIGNCERTS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r
              '.data.data["signcerts"]')

              TLSCACERTS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r
              '.data.data["tlscacerts"]')


              mkdir -p ${OUTPUT_PATH}/admincerts

              mkdir -p ${OUTPUT_PATH}/cacerts

              mkdir -p ${OUTPUT_PATH}/keystore

              mkdir -p ${OUTPUT_PATH}/signcerts

              mkdir -p ${OUTPUT_PATH}/tlscacerts


              echo "${ADMINCERT}" >> ${OUTPUT_PATH}/admincerts/admin.crt

              echo "${CACERTS}" >> ${OUTPUT_PATH}/cacerts/ca.crt

              echo "${KEYSTORE}" >> ${OUTPUT_PATH}/keystore/server.key

              echo "${SIGNCERTS}" >> ${OUTPUT_PATH}/signcerts/server.crt

              echo "${TLSCACERTS}" >> ${OUTPUT_PATH}/tlscacerts/tlsca.crt
          env:
            - name: VAULT_ADDR
              value: http://40.80.95.60:8200
            - name: KUBERNETES_AUTH_PATH
              value: devcarrier-net-auth
            - name: VAULT_APP_ROLE
              value: vault-role
            - name: VAULT_PEER_SECRET_PREFIX
              value: secretv2/data/crypto/peerOrganizations/carrier-net/users/admin
            - name: VAULT_ORDERER_SECRET_PREFIX
              value: secretv2/data/crypto/peerOrganizations/carrier-net/orderer
            - name: MOUNT_PATH
              value: /secret
          resources: {}
          volumeMounts:
            - name: certificates
              mountPath: /secret
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          imagePullPolicy: IfNotPresent
      containers:
        - name: approvechaincode
          image: hyperledger/fabric-tools:2.2.2
          command:
            - sh
            - '-c'
          args:
            - >-
              #!/bin/bash sh


              ## Checking approved chaincode

              APPROVED=$(peer lifecycle chaincode queryapproved --channelID
              ${CHANNEL_NAME} --name ${CHAINCODE_NAME} -O json | \
                jq --arg SEQUENCE "${CHAINCODE_SEQUENCE}" --arg VERSION "$CHAINCODE_VERSION" \
                'select((.sequence|tostring)==$SEQUENCE and (.version|tostring)==$VERSION)')
              if [ -n "${APPROVED}" ]

              then
                echo "chaincode ${CHAINCODE_NAME} with version ${CHAINCODE_VERSION} and sequence ${CHAINCODE_SEQUENCE} is approved in channel ${CHANNEL_NAME}, skipping... "
                exit 0
              fi


              echo $COMMIT_ARGUMENTS>COMMIT_ARGUMENTS.txt

              COMMIT_ARGUMENTS=$(< COMMIT_ARGUMENTS.txt)


              echo "Extracting package id"

              peer lifecycle chaincode queryinstalled > log.txt

              PACKAGE_ID=$(cat log.txt | grep
              "${CHAINCODE_NAME}_${CHAINCODE_VERSION}" | sed -n
              "/${CC_NAME}_${CC_VERSION}/{s/^Package ID: //; s/, Label:.*$//;
              p;}")

              echo "Package Id Extracted ${PACKAGE_ID}"


              echo "Endorsing policy:${ENDORSEMENT_POLICIES}"

              if [ -z ${ENDORSEMENT_POLICIES} ]

              then
                ## approve for myorg
                echo "peer query approve without endorsement"
                peer lifecycle chaincode approveformyorg -o ${ORDERER_URL} --tls ${CORE_PEER_TLS_ENABLED} --cafile ${ORDERER_CA} --channelID ${CHANNEL_NAME} \
                  --name ${CHAINCODE_NAME} --version ${CHAINCODE_VERSION} --package-id ${PACKAGE_ID} --sequence ${CHAINCODE_SEQUENCE} \
                  --init-required > log.txt
              else
                ## approve for myorg
                echo "peer query approve with endorsement policies"
                peer lifecycle chaincode approveformyorg -o ${ORDERER_URL} --tls ${CORE_PEER_TLS_ENABLED} --cafile ${ORDERER_CA} --channelID ${CHANNEL_NAME} \
                  --name ${CHAINCODE_NAME} --version ${CHAINCODE_VERSION} --package-id ${PACKAGE_ID} --sequence ${CHAINCODE_SEQUENCE} \
                  --init-required --signature-policy "" > log.txt  
              fi
          env:
            - name: CORE_VM_ENDPOINT
              value: unix:///host/var/run/docker.sock
            - name: FABRIC_LOGGING_SPEC
              value: debug
            - name: CORE_PEER_ID
              value: peer0.carrier-net
            - name: CORE_PEER_ADDRESS
              value: peer0.carrier-net:7051
            - name: CORE_PEER_LOCALMSPID
              value: carrierMSP
            - name: CORE_PEER_TLS_ENABLED
              value: 'true'
            - name: CORE_PEER_TLS_ROOTCERT_FILE
              value: >-
                /opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp/tlscacerts/tlsca.crt
            - name: ORDERER_CA
              value: >-
                /opt/gopath/src/github.com/hyperledger/fabric/crypto/orderer/tls/ca.crt
            - name: ORDERER_URL
              value: orderer1.supplychain-net:7050
            - name: CORE_PEER_MSPCONFIGPATH
              value: /opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp
            - name: CHAINCODE_NAME
              value: supplychain
            - name: CHAINCODE_VERSION
              value: '1'
            - name: CHAINCODE_SEQUENCE
              value: '1'
            - name: CORE_CHAINCODE_BUILDER
              value: hyperledger/fabric-ccenv:2.2.2
            - name: CHANNEL_NAME
              value: allchannel
            - name: COMMIT_ARGUMENTS
              value: \"init\",\"\"
            - name: CC_RUNTIME_LANGUAGE
            - name: ENDORSEMENT_POLICIES
          resources: {}
          volumeMounts:
            - name: certificates
              readOnly: true
              mountPath: /opt/gopath/src/github.com/hyperledger/fabric/crypto
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          imagePullPolicy: IfNotPresent
          stdin: true
          tty: true
      restartPolicy: OnFailure
      terminationGracePeriodSeconds: 30
      dnsPolicy: ClusterFirst
      serviceAccountName: vault-auth
      serviceAccount: vault-auth
      securityContext: {}
      imagePullSecrets:
        - name: regcred
      schedulerName: default-scheduler
